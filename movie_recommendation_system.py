# -*- coding: utf-8 -*-
"""Movie Recommendation system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Gu96aWHFe6u5DOsTnni_QMHDDr-ZVHy
"""

!pip install -q streamlit

import numpy as np
import pandas as pd
import ast
import pickle
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

print("Starting Pro Pipeline")

# Load Data
movies = pd.read_csv('/content/tmdb_5000_movies.csv', engine='python', on_bad_lines='warn')
credits = pd.read_csv('/content/tmdb_5000_credits.csv', engine='python', on_bad_lines='warn')

# Merge & Select ONLY the columns we need for the app
movies = movies.merge(credits, on='title')

# We keep more data this time for the UI
movies = movies[['movie_id', 'title', 'overview', 'genres', 'keywords', 'cast', 'crew', 'vote_average', 'release_date', 'runtime']]
movies.dropna(inplace=True)

# --- Helper Functions ---
def safe_literal_eval(obj):
    try:
        return ast.literal_eval(obj)
    except (ValueError, SyntaxError):
        return [] # Return an empty list for malformed entries

def convert(obj):
    return [i['name'] for i in safe_literal_eval(obj)]

def convert3(obj):
    return [i['name'] for i in safe_literal_eval(obj)[:3]] # Top 3 actors

def fetch_director(obj):
    return [i['name'] for i in safe_literal_eval(obj) if i['job'] == 'Director']

def collapse(L):
    return [i.replace(" ","") for i in L]

# Data Transformation
print("Transforming Data")
movies['genres_list'] = movies['genres'].apply(convert) # Keep original list for filtering
movies['keywords'] = movies['keywords'].apply(convert)
movies['cast_list'] = movies['cast'].apply(convert3)    # Keep original list for display
movies['crew'] = movies['crew'].apply(fetch_director)
mk_overview = movies['overview'].fillna('') # Handle potential NaN values
mk_overview = mk_overview.apply(lambda x: x.split())
movies['overview_tokens'] = mk_overview # Assign the tokenized overview

# Create Tags for the Algorithm (Technical part)
movies['genres_tags'] = movies['genres_list'].apply(collapse)
mk_keywords = movies['keywords'].apply(collapse)
mk_cast = movies['cast_list'].apply(collapse)
mk_crew = movies['crew'].apply(collapse)
mk_genres = movies['genres_tags']

movies['keywords_tags'] = mk_keywords
movies['cast_tags'] = mk_cast
movies['crew_tags'] = mk_crew
mk_overview = movies['overview_tokens']

movies['tags'] = mk_overview + mk_genres + mk_keywords + mk_cast + mk_crew

# Final DataFrame (Includes metadata for the UI)
final_df = movies[['movie_id', 'title', 'tags', 'vote_average', 'release_date', 'runtime', 'genres_list', 'cast_list', 'overview']].copy()
final_df['tags'] = final_df['tags'].apply(lambda x: " ".join(x).lower())

# AI Model Training
print("Training AI Model")
cv = CountVectorizer(max_features=5000, stop_words='english')
vectors = cv.fit_transform(final_df['tags']).toarray()
similarity = cosine_similarity(vectors)

# Saving
print("Saving High-Res Model files")
pickle.dump(final_df.to_dict(), open('movie_list.pkl', 'wb'))
pickle.dump(similarity, open('similarity.pkl', 'wb'))
print("‚úÖ Done! Ready for the Super App.")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pickle
# import requests
# import pandas as pd
# 
# # Page Config
# st.set_page_config(page_title="MovieGenius", layout="wide", page_icon="üçø")
# 
# st.markdown("""
# <style>
#     .stButton>button {
#         width: 100%;
#         background-color: #ff4b4b;
#         color: white;
#         border-radius: 5px;
#     }
#     .big-font { font-size: 20px !important; font-weight: bold; }
# </style>
# """, unsafe_allow_html=True)
# 
# @st.cache_data
# def load_data():
#     movies_dict = pickle.load(open('movie_list.pkl','rb'))
#     similarity = pickle.load(open('similarity.pkl','rb'))
#     df = pd.DataFrame(movies_dict)
#     return df, similarity
# 
# def fetch_poster(movie_id):
#     try:
#         url = f"https://api.themoviedb.org/3/movie/{movie_id}?api_key=8265bd1679663a7ea12ac168da84d2e8&language=en-US"
#         data = requests.get(url).json()
#         return "https://image.tmdb.org/t/p/w500/" + data['poster_path']
#     except:
#         return "https://via.placeholder.com/500x750?text=No+Image"
# 
# def get_recommendations(movie, movies, similarity):
#     idx = movies[movies['title'] == movie].index[0]
#     distances = sorted(list(enumerate(similarity[idx])), reverse=True, key=lambda x: x[1])
# 
#     recommendations = []
#     for i in distances[1:6]:
#         row = movies.iloc[i[0]]
#         recommendations.append({
#             'title': row.title,
#             'id': row.movie_id,
#             'rating': row.vote_average,
#             'year': str(row.release_date)[:4] if row.release_date else "N/A"
#         })
#     return recommendations
# 
# try:
#     movies, similarity = load_data()
# 
#     # Sidebar
#     with st.sidebar:
#         st.title("üçø MovieGenius")
#         st.write("Advanced Content-Based Filtering")
# 
#         #  Genre Filter
#         all_genres = sorted(list(set([g for sublist in movies['genres_list'] for g in sublist])))
#         selected_genre = st.selectbox("Filter by Genre (Optional)", ["All"] + all_genres)
# 
#         # Filter the movie list based on genre
#         if selected_genre != "All":
#             filtered_movies = movies[movies['genres_list'].apply(lambda x: selected_genre in x)]
#         else:
#             filtered_movies = movies
# 
#         movie_list = filtered_movies['title'].values
# 
#         st.markdown("---")
#         st.caption("Built with Streamlit & Scikit-Learn")
# 
#     st.header("üé¨ What are you watching today?")
# 
#     col1, col2 = st.columns([3, 1])
#     with col1:
#         selected_movie = st.selectbox("Type or select a movie", movie_list)
#     with col2:
#         st.write("")
#         st.write("")
#         btn = st.button('üîç Find Similar Movies')
# 
#     if btn:
#         with st.spinner('Analyzing plot, cast, and genres...'):
#             # Get Details of Selected Movie
#             movie_details = movies[movies['title'] == selected_movie].iloc[0]
#             recs = get_recommendations(selected_movie, movies, similarity)
# 
#             #  The Selected Movie Details
#             st.markdown("Selection Details")
#             c1, c2 = st.columns([1, 3])
# 
#             with c1:
#                 st.image(fetch_poster(movie_details.movie_id), use_column_width=True)
# 
#             with c2:
#                 st.subheader(f"{movie_details.title} ({str(movie_details.release_date)[:4]})")
#                 st.markdown(f"‚≠ê **{movie_details.vote_average}/10** | ‚è±Ô∏è **{movie_details.runtime} min**")
#                 st.write(f"**Cast:** {', '.join(movie_details.cast_list)}")
#                 st.info(movie_details.overview)
# 
#             st.markdown("---")
# 
#             # Recommendations
#             st.markdown(" Recommended for You")
# 
#             cols = st.columns(5)
#             for i, col in enumerate(cols):
#                 rec = recs[i]
#                 with col:
#                     st.image(fetch_poster(rec['id']), use_column_width=True)
#                     st.markdown(f"**{rec['title']}**")
#                     st.caption(f"‚≠ê {rec['rating']} | üìÖ {rec['year']}")
# 
# except FileNotFoundError:
#     st.error(" Model files not found! Please run the 'Pro Data Pipeline' cell first.")

import subprocess
import time

print(" Your Tunnel Password is:")
!curl ipv4.icanhazip.com

print("\n Starting MovieGenius...")
process = subprocess.Popen(["streamlit", "run", "app.py"])

print(" Click the link below and enter the Password above:")
!npx localtunnel --port 8501